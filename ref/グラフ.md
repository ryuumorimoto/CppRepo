# グラフの表現
- 連結リスト
その頂点から出ている辺O(1)でわかる
- 隣接行列
O(1)で頂点同士の関係を調べられる
辺の削除や、追加を効率的にできる
その頂点から出ている辺を把握する時（探索時など）に、O(n)かかる（ここ重要）
メモリが多く必要

# 最小全域木
グラフの全ての頂点を含む部分グラフであって、木である限り（閉路が存在しない）多くの辺を持つもの
また重み付きグルフの場合、重みの和が最小となるものである
プリムのアルゴリズムで求められる
- 13-2
forループの各ステップで、最小木に含まれたグループと、残りの間の最小距離を求め、それを最小木のグループに追加する、O(N^2)
- 15-5
優先度付きキューを用いることで計算量を削減できる

# 全点間最短経路（ダイクストラ法、ワーシャルフロイド）
- ダイクストラ法
頂点間のコストが最小となる経路を発見する
Vから一つずつ頂点を追加していくが、その時にcostArrayが最小のものを追加する。また追加後にcostArrayを
```
rep(i, n) {
    if(costArray[i] == -1) { continue;}
    if(costArray[newVertex] + M[newVertex][i]< costArray[i]) {
        costArray[i] = costArray[newVertex] + M[newVertex][i];
    }
}
```
で更新する。
最小全域木は所属グループと新しい頂点の最短距離のものを追加していったが、ダイクストラでは追加する際にrootからの距離でcostArrayを更新し、それの最小値のものを追加していく。
O(n^2)
優先度付きキューを用いることで、Vだけ頂点が取り出され、Eだけ頂点が挿入される。また優先度付きキューの挿入と、削除の計算量はO(logn)であるのでO((V+E)logn)である。

- ワーシャルフロイド法
DPを用いる
A^k(i, j) を、kまでの頂点を経由したiからjまでの最短経路とする。
DPテーブルは一次元だが、データが二次元となる。
A^(k+1)(i, j) = min(A^k(i, j), A^k(i, k) + A^k(k, j))で更新。
A^V(i, i)のいずれかが歩の閉路が存在し、最短距離を定義できない
また経路がない時にINT_MAXを用いているが、これと、これに負の経路を足したもので更新されることがあるのでINT_MAXのルートの時はbreakする。

# Disjoint
14-1
東大電気情報（2022)で出たやつ
一次元配列で木を表現する、ヒープが配列のindexが木の位置を表していたが、Disjointではある要素の親が配列に収められている。それを要素=親となるまで辿ることでその要素のrootにたどり着く、つまりグループ分けができる。
このデータ構造のボトルネックは、木の高さである。結合時に、木の高さ(rank)や、要素数でどちらを親にして合併するかを選択することでlogNで探索ができる。また探索時に木の高さが低くなるように親を更新すると良い。


# 領域探索
14-2
事前にデータが決まっている静的なデータを、探索がしやすいように二分枝として構築することで、その後の領域探索の計算量が少なくなる。
二分枝の構築方法としては、１次元データの場合はsortして、midをrootとして部分木を返すのを繰り返す。
二次元データの場合では、depthが偶数または奇数でsortするデータを変える。また探索時にも同じ規則で探索する。

# トポロジカルソート
15-2
閉路のない有効グラフに対して、物事の手順を表すデータ構造として応用することができる。適用することで、着手すべき順番に仕事を列挙することができる。
以下二つとも計算量はO(V+E)
(1)幅優先探索
頂点を入力で受ける際に、つながる先の頂点も記録しておく。その後forで各頂点に対してbfs探索を行う。繋がっている頂点を訪問し、訪問したらつながる先の頂点を減らし、０であれば答えに含める。

(2)深さ優先探索
訪問したらvisitedをtrueにする。dfsし終わったら答えとしてstackに入れていく。これはdfsで探索してより深いところのやつはトポロジカルソートでも後の方になるということ。



# 関節点
一つずつ頂点がなかったとして、探索を行いグループ分けをすることで関節点かどうかを確かめられるが、それは時間がかかる。そこで一度の探索時に、探索した順番と、lowestArrayを求める。lowestArrayとは自分の子供の中で最小のlowestArrayまたは、その頂点から繋がっているback edgeの探索した順番。parentの探索した順番<=lowestArrayならば関節点となる。そのparentは関節点となる。

#　直径
ある点から一番遠い点を求める。次にその点から一番遠い点を求めると、直径が得られる。