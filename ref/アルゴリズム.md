# 尺取法
静的な配列で、条件を満たす区間（連続）のうち、最小（最大）の長さを求める。またはその数を数える
```
// 区間の和がx以下になる部分配列の数を数える
long long getWindowNum(int* array, int n, long long x) {
    int right = 0;
    long long sum = 0;
    long long ans = 0;
    for (int left = 0; 0 < n; left++) {
        // ここでのrightは次を表している。
        while (right < n && sum + array[right] <= x) {
            sum = sum + array[right];
            right += 1;//rightを次に備えてあげておく
        }
        /*cout << "left: " << left << " right: " << right
             << " += " << right - left + 1 << endl;*/
        ans += (right - left);//rightが進んでおらすleftと同じならばleft = rightで条件に合わなかったということ
        if (right == left) {            
            right += 1;// leftとright両方をインクリメント
        } else {
            sum -= array[left];
        }
    }
    return ans;
}
```

# 最大部分和列
普通にやると、O(n^2)
DPの一種であるDadane's algorithmによりO(n)
考え方は、array[i]を最大部分和列に含めるかを考える際に、そこまでの和が0以下になれば、そこより左の配列は含めても仕方ないということ
```
best = -1e9
cur = 0
        
for i in range(len(nums)):
    // curが部分数列の累積和を保存しておく変数
    cur = max(nums[i], nums[i] + cur)
    best = max(best, cur)
        
    return best
```

# ベルマンフォード法
負の経路が存在するグラフでも適用可能。詳細は東大過去問ノートP31に書いた。




## ヒューリスティック探索の章
# バックトラック
19-2
可能性のある状態を体系的に試していき、現在の状態から解を得られないとなった時に探索を打ち切理、一つ前の状態から探索を再開する。

# 19-3
幅優先探索で探索かつ、mapに探索済みの状態を保存しておくことで考えられる状態をじわじわ進めていく。
深さ優先探索では、最短の解を求めるとは限らない
無駄な探索をしてしまう
適度な深さで探索を打ち切らなければ、全探索してしまう

# 反復深化
dfsにおいて、深さの上限をだんだんと上げていく方法。メモリには記録しないため（高速化のため）、一つ前の操作に戻らないような工夫が必要。深さの上限を超えると、探索を打ち切る。
その際に、探索中の深さと、その状態でのヒューリスティックの和がlimitを超えると探索を打ち切るようにしたものがヒューリスティック探索である。
19-3.cppでは、limitを１ずつ上げていき、探索中にヒューリィと深さの和がそれを超えると探索と打ち切る。

A*法
19-3_A*.cppでは探索済みの状態をmapで保存しておき、priority_queueに優先度を深さとヒューリスティックの和が小さい順に取り出せるようにしておく。このPQから値を取り出しつつ、探索を進めていく。


